<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<title>vue</title>
<meta name="description" content="">
<meta name="keywords" content="">
<link href="" rel="stylesheet">
</head>
<body>
   	vue 的安装：
   		1、安装全局vue脚手架
   			npm install -g vue-cli
		2、转到相应目录下，初始化项目
			vue init webpack 项目名（不能有大写字母）

		3、按照提示，cmd到新建的项目下，
			npm run dev

	安装vue调式工具vue-devtools:
		https://www.cnblogs.com/yuqing6/p/7440549.html

	安装element-ui   https://segmentfault.com/a/1190000012015667
		cd 到项目下：
			npm i element-ui -S


	<!--
    面向数据编程方式
	vue 模板语法

	vue挂载点：vue实例对应的dom节点
	template 模块

		输出变量：
			{{msg}}  插值表达式
			{{msg+'aaa'}}

		v-bind  绑定元素的属性 可用简写
		v-bind	单身绑定：数据决定页面的显示内容，但是页面数据无法决定数据的内容
		v-model	双向绑定：<div v-model="content">


			<div id="bg" v-bind:data-bg="bg1">
			<div id="bg" :data-bg="bg2">

		v-html:输出html模板
			<div v-html='template'></div>

		v-on：绑定事件 两种写法
			<button v-on:click="submit()">加法</button>
			<button @click="submit()">加法</button>

		v-text
			<div v-text="name+'aa'"></div>

		v-html
			<div v-text="name+'aa'"></div>


		计算属性：computed 数据联动  侦听vue实例中所有变量的变化
			1、getter 默认就有
			2、setter

		侦听器：watch 异步场景 侦听单个变量的变化

			内置缓存的，如果里面参与计算的值没有发生变化，那么computed不是调用计算，调用缓存上一次的数据  测试，只改变count的值，计算属性也可用方法来实现，但是方法没有缓存，性能也不如计算属性,也可以用watch来监听变化，wacth也有缓存机制

		条件渲染:

		v-if v-else-if v-else
			v-if 条件不为真是直接就不在dom存在

		v-show:	条件为真显示，否则不显示，在dom里存在，display="none",性能比v-if高

		v-for 循环

		v-bind:style=""  绑定内联样式

		vue中对数组的操作方法
			push 添加到最后
			pop  删除
			shift  删除并返回数组的第一个元素。
			unshift 添加到第一个
			splice(index,index1,{id,'333',name:'lily'})  index:删除数据在数组中的下标，index1:在数组中要添加的位置
			sort:排序
			reverse:反序



		new Vue({
    		el:"#bg",  //挂载点元素
    		data:{
    			msg:'hello vue!',
    			bg1:'app-bg1',
    			template:'<div>hello template！</div>',
    			url:'https://www.baidu.com',
    			count:0
    		},
    		methods:{
    			submit:function(){
    				this.count++
    			}
    		}
    	})

		安装vue的开发的标准工具
    	npm install -g @vue/cli   3.X 版本

    	创建文件：
    	vue create my-project
    	vue ui 图形界面创建vue项目

    	组件化的目的：实现模块的复用/高效的效率/开发单页面复杂应用
    		如果拆分：
    			300行原则/复用原则/业务复杂性原则

			组件化带来的问题：
				组件状态管理(vuex)
				多组件的混合使用，多页面，复杂业务(vue-router)
				组件间的传参、消息、事件管理(props,emit/on,bus)

		风格指南：
			好习惯，少走坑
			写出自己看得懂的代码
			写出别人看得懂的代码
			查看官方文档：
			https://cn.vuejs.org/v2/style-guide/

		单文件组件：包含了template  script  style

		vue-router:路由管理工具	配置在router.js里修改

		vuex: 组件状态的管理
			多个视图依赖同一个状态(eg:菜单导航)
			来自不同视图的行为需要变更同一状态(eg:评论弹幕)

		在vue-cli 下，数据是一个函数，通过return 返回所有数据，在非脚手架框架下data是一个对象

		vue调度工具 vue-devtools
			1.console.log
			2.alert
			3.debugger
			4.vm 实例 window对象绑定

		vue组件与实例之间的关系：
			每一个组件也是一个vue实例，也可以添加数据及绑定事件
			如果一个vue实例没有定义template，刚默认为根挂载点下的所有dom元素为模板
			父组件是通过属性的形式向子组件传值的

		开发工作流：
			1.需求调研
			2.交互设计、逻辑设计、接口设计
			3.代码实现（三分之一的时间）、测试运行（10%-20%的时间）、线上部署

		git
			git branch -a 查看所有分支
			git checkout -b dev
			推送远程：git push origin dev
			合并到master分支：
				git checkout master
				git merge dev
				git push origin master

			删除本地分支：git branch -D dev
			删除远程服务器上的分支：git push origin :dev

			回退：git reset --hard head^   退回上一个版本
			回退版本：git rest --hard  HEAD@{1}

			查看操作日志：
			git log
			git reflog


		直接引入vue.js 的方式 叫到MVVM模式
			传统MVP模式  面向dom开发
			model(数据层)   presenter(控制层)  view(视图层dom)

			vue使用的是MVVM模式  面向数据开发
			model(重点，以数据为操作中心)  view  viewmodel(dom listeners/data bindings)


		vue 生命周期函数：vue实例到达某一个时间点自动执行的函数


		ref:通过ref获取dom节点
			this.$refs.aaa

		props:
		非props: 父组件给子组件传递了参数，但是子组件未在props里接收，此属性则为非props的属性，并且此属性会在子组件的dom中显示出来

     -->
</body>
</html>
